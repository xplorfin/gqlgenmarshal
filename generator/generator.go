package generator

import (
	"bytes"
	"fmt"
	"go/ast"
	"go/format"
	"io/ioutil"
	"log"
	"os"
	"path/filepath"
	"strings"

	"golang.org/x/tools/go/packages"
)

// Generator holds the state of the analysis. Primarily used to buffer
// the output for format.Source.
type Generator struct {
	buf bytes.Buffer // Accumulated output.
	pkg *Package     // Package we are scanning.

	TrimPrefix       string
	LCaseStringCheck bool
}

func (g *Generator) Printf(format string, args ...interface{}) {
	fmt.Fprintf(&g.buf, format, args...)
}

// Generate produces the MarshalGQL and UnmarshalGQL methods for the named type(s).
func (g *Generator) Generate(types []string, args []string, dir string, output *string) {
	g.parsePackage(args)

	// Print the header and package clause.
	g.Printf("// Code generated by \"gqlgenmarshal %s\"; DO NOT EDIT.\n", strings.Join(os.Args[1:], " "))
	g.Printf("\n")
	g.Printf("package %s\n\n", g.pkg.name)

	g.Printf("import(\n")
	g.Printf("\t\"fmt\"\n")
	g.Printf("\t\"io\"\n")
	g.Printf("\t\"strings\"\n")
	g.Printf("\t\"encoding/json\"\n")
	g.Printf(")\n\n")

	for _, typeName := range types {
		g.generate(typeName)
	}

	// Format the output.
	src := g.format()

	// Write to file.
	outputName := *output
	if outputName == "" {
		baseName := fmt.Sprintf("%s_gqlgenmarshal.go", types[0])
		outputName = filepath.Join(dir, strings.ToLower(baseName))
	}

	err := ioutil.WriteFile(outputName, src, 0644)
	if err != nil {
		log.Fatalf("writing output: %s", err)
	}
}

func (g *Generator) generate(typeName string) {
	values := make([]Value, 0, 100)
	for _, file := range g.pkg.files {
		// Set the state for this run of the walker.
		file.typeName = typeName
		file.values = nil
		if file.file != nil {
			ast.Inspect(file.file, file.genDecl)
			values = append(values, file.values...)
		}
	}

	if len(values) == 0 {
		log.Fatalf("no values defined for type %s", typeName)
	}

	// Generate code that will fail if the constants change value.
	g.Printf("func _() {\n")
	g.Printf("\t// An \"invalid array index\" compiler error signifies that the constant values have changed.\n")
	g.Printf("\t// Re-run the stringer command to generate them again.\n")
	g.Printf("\tvar x [1]struct{}\n")
	for _, v := range values {
		g.Printf("\t_ = x[%s - %s]\n", v.originalName, v.str)
	}
	g.Printf("}\n")

	runs := splitIntoRuns(values)

	g.build(runs, typeName)

	// fmt.Println(string(g.format()))
}

// parsePackage analyzes the single package constructed from the patterns and tags.
// parsePackage exits if there is an error.
func (g *Generator) parsePackage(patterns []string) {
	cfg := &packages.Config{
		Mode: packages.LoadSyntax,
		// TODO: Need to think about constants in test files. Maybe write type_string_test.go
		// in a separate pass? For later.
		Tests: false,
	}

	pkgs, err := packages.Load(cfg, patterns...)
	if err != nil {
		log.Fatal(err)
	}
	if len(pkgs) != 1 {
		log.Fatalf("error: %d packages found", len(pkgs))
	}
	g.addPackage(pkgs[0])
}

// addPackage adds a type checked Package and its syntax files to the generator.
func (g *Generator) addPackage(pkg *packages.Package) {
	g.pkg = &Package{
		name:  pkg.Name,
		defs:  pkg.TypesInfo.Defs,
		files: make([]*File, len(pkg.Syntax)),
	}

	for i, file := range pkg.Syntax {
		g.pkg.files[i] = &File{
			file:       file,
			pkg:        g.pkg,
			trimPrefix: g.TrimPrefix,
		}
	}
}

// format returns the gofmt-ed contents of the Generator's buffer.
func (g *Generator) format() []byte {
	src, err := format.Source(g.buf.Bytes())
	if err != nil {
		// Should never happen, but can arise when developing this code.
		// The user can compile the output to see the error.
		log.Printf("warning: internal error: invalid Go generated: %s", err)
		log.Printf("warning: compile the package to analyze the error")
		return g.buf.Bytes()
	}
	return src
}

// build generates the variables and String method for a single run of contiguous values.
func (g *Generator) build(runs [][]Value, typeName string) {
	values := runs[0]
	g.Printf("\n")

	var (
		encodeSuffix string
		underlying   string
	)

	// We can safely assume that all values for this type are stringers.
	if values[0].isStringer {
		encodeSuffix = ".String()"
		underlying = "string"
	} else {
		underlying = "int"
	}

	// adding the marshal function is pretty easy.
	g.Printf(marshalFuncString, typeName, encodeSuffix)
	g.Printf("\n")

	// adding the unmarshal function is not.
	g.Printf(unmarshalFuncString, typeName, underlying)

	g.Printf("\n")

	var checkWithTypeConv string
	switch underlying {
	case "string":
		if g.LCaseStringCheck {
			checkWithTypeConv = "strings.ToLower(check)"
		} else {
			checkWithTypeConv = "check"
		}
	case "int":
		checkWithTypeConv = typeName + "(check)"
	}

	g.Printf("\tswitch %[1]s {\n", checkWithTypeConv)
	for _, v := range values {
		if g.LCaseStringCheck && encodeSuffix != "" {
			g.Printf("\tcase strings.ToLower(%[1]s%[2]s):\n", v.name, encodeSuffix)
		} else {
			g.Printf("\tcase %[1]s%[2]s:\n", v.name, encodeSuffix)
		}
		g.Printf("\t\t*i = %[1]s\n", v.name)
	}
	g.Printf("\tdefault:\n")
	g.Printf("\t\treturn fmt.Errorf(\"unknown %[1]s value %[2]s\", check)", typeName, "%[1]v")

	g.Printf("\n\t}\n")
	g.Printf("\n\treturn nil\n")
	g.Printf("}\n")
}

// Arguments to format are:
//	[1]: type name
//  [2]: if the type has a String() method (thus implementing fmt.Stringer), then ".String()".
//		 otherwise, ""
const marshalFuncString = `func (i %[1]s) MarshalGQL(w io.Writer) {
	if err := json.NewEncoder(w).Encode(i%[2]s); err != nil {
		panic(fmt.Errorf("error marshaling %[1]s"))
	}
}
`

// Arguments to format are:
//	[1]: type name
//  [2]: underlying type name. If the type has a String() method, this can be "string"; otherwise, will most likely
//		 be "int".
const unmarshalFuncString = `func (i *%[1]s) UnmarshalGQL(v interface{}) error {
	check, ok := v.(%[2]s)
	if !ok {
		return fmt.Errorf("%[1]s must be a valid %[2]v value")
	}
`
